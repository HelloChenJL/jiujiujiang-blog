---
title: Vue.js设计与实现1-3章-读书笔记
date: 2026-02-06T05:11:00.365Z
categories:
  - Vue相关
tags:
  - Vue
---
# Vue.js设计与实现1-3章-读书笔记

# /\*\*/[#Vue.js设计与实现1-3章-读书笔记-](#Vue.js设计与实现1-3章-读书笔记-)[第1章 权衡的艺术](#Vue.js设计与实现1-3章-读书笔记-第1章权衡的艺术)[1.1命令式和声明式](#Vue.js设计与实现1-3章-读书笔记-1.1命令式和声明式)[1.2性能与可维护性的权衡](#Vue.js设计与实现1-3章-读书笔记-1.2性能与可维护性的权衡)[1.3虚拟dom的性能到底如何](#Vue.js设计与实现1-3章-读书笔记-1.3虚拟dom的性能到底如何)[1.4运行时和编译时](#Vue.js设计与实现1-3章-读书笔记-1.4运行时和编译时)[第2章 框架设计的核心要素](#Vue.js设计与实现1-3章-读书笔记-第2章框架设计的核心要素)[2.1提升用户的开发体验](#Vue.js设计与实现1-3章-读书笔记-2.1提升用户的开发体验)[2.2控制框架代码的体积](#Vue.js设计与实现1-3章-读书笔记-2.2控制框架代码的体积)[2.3框架要做到良好的Tree-Shaking](#Vue.js设计与实现1-3章-读书笔记-2.3框架要做到良好的Tree-Shaking)[2.4框架应该输出怎样的构建产物](#Vue.js设计与实现1-3章-读书笔记-2.4框架应该输出怎样的构建产物)[2.5特性开关](#Vue.js设计与实现1-3章-读书笔记-2.5特性开关)[2.6错误处理](#Vue.js设计与实现1-3章-读书笔记-2.6错误处理)[2.7良好的TS类型支持](#Vue.js设计与实现1-3章-读书笔记-2.7良好的TS类型支持)[第3章 Vue.js3 的设计思路](#Vue.js设计与实现1-3章-读书笔记-第3章Vue.js3的设计思路)[3.1声明式地描述UI](#Vue.js设计与实现1-3章-读书笔记-3.1声明式地描述UI)[3.2初识渲染器](#Vue.js设计与实现1-3章-读书笔记-3.2初识渲染器)[3.3组件的本质](#Vue.js设计与实现1-3章-读书笔记-3.3组件的本质)[3.4模板的工作原理](#Vue.js设计与实现1-3章-读书笔记-3.4模板的工作原理)[3.5Vue.js 是各个模块组成的有机整体](#Vue.js设计与实现1-3章-读书笔记-3.5Vue.js是各个模块组成的有机整体)

# 第1章 权衡的艺术

## 1.1命令式和声明式

从范式上来看，视图层框架通常分为命令式和声明式，它们各有优缺点。像jquery就是命令式的更加注重过程，具体的描述和代码能产生一一对应的关系，而vue是声明式，更注重结果，实现的过程全部再vue内部帮我们处理了

## 1.2性能与可维护性的权衡

像vue本身就是封装了命令式代码才实现了面向用户的声明式，所以命令式的代码的性能优于声明式代码的性能。但是vue为啥要使用声明式的设计方案呢，原因就是声明式代码可维护性更强，因为命令式的需要维护的式整个代码实现的过程，包括要手动完成dom的创建、更新、删除等工作，而vue展示的代码就是我们要的结果，看上去更直观，过程的事情vue已经封装好了，vue框架的设计着就是让在保持可维护性的同时让性能损失最小化。

```text/javascript
命令式： 
const div = document.querySelector('#app') // 获取 div
div.innerText = 'hello world' // 设置文本内容
div.addEventListener('click', () => { alert('ok') }) // 绑定点击事


声明式： 
<div @click="() => alert('ok')">hello world</div>
```

## 1.3虚拟dom的性能到底如何

声明式代码的更新性能消耗 = 找出差异的性能消耗+ 直接修改的性能消耗

而所谓的虚拟 DOM，就是为了最小化找出差异这一步的性能消耗而出现的

虚拟Dom相比js的innerHtml 在创建页面的时候虚拟dom没什么太大的优势，但是在修改的时候innerHtml 虽然 虚拟Dom会在js层面多加一个diff，但是毕竟是js所有不会产生数量级差异、但是你在dom层面innerhtml会将dom全量更新，对于虚拟dom他只更新有变化的内容，这样当页面大的情况，innerHtml会承担的更多。

## 1.4运行时和编译时

当设计一个框架的时候，我们有三种选择：纯运行时的、运行时 +编译时的或纯编译时的。

运行时:需要用户自己写数据对象自己渲染（不能分析用户提供的内容虽然性能较好，但是很不灵活，比较麻烦不直观）

运行时+编译时：用户调用某个方法，将HTML 标签编译成树型结构的数据对象然后执行Render进行渲染（vue现在用的这种方式，既可以分析用户提供的内容，而且再得到这些信心之后做进一步优化）

纯编译：将HTML 标签直接编译成命令式代码（由于不用运行，直接编译成命令式代码，性能会更好，但是这种做法有损灵活性，用户提供的内容必须编译后才能使用）

# 第2章 框架设计的核心要素

## 2.1提升用户的开发体验

框架的设计需要考虑很多方面，并不只是说能把功能开发完成，这里有很多的学问，例如我们的框架给用户提供哪些构建产物，产物的格式如何？还有当用户没有以预期的发生你还是使用框架的时候，框架要如何让打印合适的警告信息，从而提供更好的开发体验让用户快速识别问题

同时在页面打印信息有的时候不够直观例如打印一个ref数据的时候，发现很不直观，除了可以使用.value可以很直观，还可以在浏览器进行设置，浏览器允许我们编写自定义的 formatter，从而自定义输出形式。在 Vue.js3 的源码中，你可以搜索到名为 initCustomFormatter 的函数，该函数就是用来在开发环境下初始化自定义 formatter 的。以 Chrome为例，我们可以打开 DevTools 的设置，然后勾选 console——custome famatters

![image2024-9-12_9-27-35.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/8180135318765114356/confluenceIMG/233276775/233276079.png)

## 2.2控制框架代码的体积

框架的大小也是衡量框架的标准之一。在实现同样功能的情况下，当然是用的代码越少越好，这样体积就会越小，最后浏览器加载资源的时间也就越少。但是与之前的提供越完善的警告信息就意味着我们要编写更多的代码相悖，vue对此做了处理，\_\_DEV\_\_来区分是否开发环境的，对于警告的代码VUE源码使用\_\_DEV\_\_里是否是true来区分是否要执行警告的代码，这样在开发环境提供友好的警告信息的同时，不会增加生产环境代码的体积。

## 2.3框架要做到良好的Tree-Shaking

上述提到构建工具使用预定义常量\_\_DEV\_\_可以避免打包体积变大，但是从用户的角度看还是不够，例如在vue中会自带一些组件例如 <Transition> 组件，如果我没项目中根本没有这个组件，那么他的代码是不需要包含在最终的构建资源中的，这就是作到这一点需要的 Tree-Shaking，什么是Tree-Shaking呢？Tree-Shaking就是消除哪那些永远不会被执行的代码，现在的打包工具都支持 Tree-Shaking，有些时候一些代码执行后只是读取也没有什么意义，但是打包工具不能直接识别，像rollup或者webpak这些工具会提供一个机制，让我们能明确的告诉他们这段代码可以放心移除。例如vue在源码会写很多的/\*#\_\_PURE\_\_\*/ 其作用就是告诉打包工具可以放心的进行Tree-Shaking。

## 2.4框架应该输出怎样的构建产物

不同类型的产物是为了满足不同的需求。为了让用户能够通过 <script> 标签直接引用并使用，我们需要输出 IIFE 格式的资源，即立即调用的函数表达式。为了让用户能够通过 <script type="module"> 引用并使用，我们需要输出ESM 格式的资源。这里需要注意的是，ESM 格式的资源有两种：用于

浏览器的 esm-browser.js 和用于打包工具的 esm-bundler.js。它们的区别在于对预定义常量 \_\_DEV\_\_ 的处理，前者直接将 \_\_DEV\_\_ 常量替换为字面量 true 或 false，后者则将 \_\_DEV\_\_ 常量替换为process.env.NODE\_ENV !== 'production' 语句。

这样做的好处是，用户可以通过 webpack 配置自行决定构建资源

的目标环境，但是最终效果其实一样，这段代码也只会出现在开发环

境中。

## 2.5特性开关

框架会提供多种能力或功能。有时出于灵活性和兼容性的考虑，对于同样的任务，框架提供了两种解决方案，例如 Vue.js 中的选项对象式 API 和组合式 API 都能用来完成页面的开发，两者虽然不互斥，但从框架设计的角度看，这完全是基于兼容性考虑的。有时用户明确知道自己仅会使用组合式 API，而不会使用选项对象式 API，这时用户可以通过特性开关关闭对应的特性，这样在打包的时候，用于实现关闭功能的代码将会被 Tree-Shaking 机制排除。原理类似于\_\_DEV\_\_根据不同的构建方式，进行对特性开关进行配置来实现例如：

  

```text/x-java
// webpack.DefinePlugin 插件配置
new webpack.DefinePlugin({
 __VUE_OPTIONS_API__: JSON.stringify(true) // 开启特性
})
```

## 2.6错误处理

框架错误处理的好坏直接决定了用户应用程序的健壮性，也可以减少用户处理错误的心智负担，vue提供了统一的错误处理接口，这样用户可以通过注册自定义的错误处理函数来处理全部的异常，原理是vue中使用callWithErrorHandling函数内部统一捕获错误，然后把错误传递给用户注册的错误处理程序

## 2.7良好的TS类型支持

使用 TS 编写框架和框架对 TS 类型支持友好是两件完全不同的事”。有时候为了让框架提供更加友好的类型支持，甚至要花费比实现框架功能本身更多的时间和精力。

# 第3章 Vue.js3 的设计思路

## 3.1声明式地描述UI

vue框架采用的是声明式,声明式的好处是在于他直接描述结果、用户不需要关注过程，他也同样支持使用虚拟dom来描述UI,虚拟dom要比模板更灵活，但模板要比虚拟dom更加直观。

## 3.2初识渲染器

虚拟dom怎么变成真实的dom然后渲染到浏览器的呢，就是通过渲染器来执行的，他的原理其实就是，递归遍历虚拟dom对象，并调用原生domAPI来完成真实dom的创建。渲染器的精髓在于后续的更新，他会通过diff算法找出变更点，然后只更新需要更新的内容。

## 3.3组件的本质

虚拟DOM除了能够描述真实的DOM之外，还能够描述组件，但是组件并不是真实的DOM元素，组件就是一组DOM元素的封装，DOM元素就是组件要渲染的内容，它可以是一个返回虚拟DOM的函数，也可以是一个对象，但这个对象下必须有一个函数用用来产出组件要渲染的虚拟DOM。渲染器在渲染组件的时候，会先获取组件要渲染的内容，即执行组件的渲染函数并得到其返回值，我们称之为 subtree，最后再递归地调用渲染器将 subtree 渲染出来即可。

## 3.4模板的工作原理

模板是如何工作的呢，那就是Vue框架的另一个重要的组成部分：编译器。编译器和渲染器一样，只是一段程序而已，不过他的工作内容不同，编译器的作用就是将模板编译成渲染函数例如：

```text/x-java
<div @click="handler">click me</div>
对于编译器来说，模板就是一个普通的字符串，它会分析该字符串并生成一个功能与之相同的渲染函数：
render() {
 return h('div', { onClick: handler }, 'click me') 
}
```

所以不管是模板还是手写的虚拟DOM(渲染函数)，对于一个组件来说，他要渲染的内容都是通过渲染函数产生的，然后渲染器再把渲染函数返回的虚拟DOM渲染为真实DOM,这就是模板的工作原理。

**总结：当我们在vue文件的时候写的template的内容，vue的编译器会进行识别，进行编译成一个渲染函数，渲染函数返回需要渲染的内容，然后通过渲染器将这些虚拟DOM渲染为真实DOM**

## 3.5Vue.js 是各个模块组成的有机整体

编译器和渲染器之间是存在信息交流的，它们互相配合使得性能进一步提升，而它们之间交流的媒介就是虚拟 DOM 对象。编译器、渲染器都是 Vue.js 的核心组成部分，它们共同构成一个有机的整体，不同模块之间互相配合，进一步提升框架性能。

  

