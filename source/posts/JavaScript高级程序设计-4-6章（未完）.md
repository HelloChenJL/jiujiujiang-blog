---
title: JavaScript高级程序设计-4-6章（未完）
date: 2026-02-06T05:08:29.046Z
categories:
  - 学习笔记
tags:
  - JavaScript
---
# JavaScript高级程序设计-4-6章（未完）

# 第4章 变量、作用域和内存问题

1.  **原始值与引用值**  
    变量有两种类型：**原始值、引用值**。  
    原始值：Undefined、Null、Boolean、Number、String 和 Symbol。  
    引用值：保存在内存中的对象。（访问内存中的对象其实是访问引用值，因为JavaScript 不允许直接访问内存位置）
    
    1.  **动态属性**  
        引用值可以动态修改、添加和删除其属性的方法，原始值不可以，原始值动态的添加属性或是undefined  
        注意：原始类型的初始化可以只使用原始字面量形式。
        
    2.  复制值  
        原始值复制之后互相不干扰，引用值因为复制的是指针，用的是同一块内存地址，修改一个会影响另一个值。
        
    3.  **传递参数**  
        在按值传递参数时，值会被复制到一个局部变量。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量（传的是指针），这意味着对本地变量的修改会反映到函数外部。
        
    4.  **确定类型typeof** 操作符：判断一个变量是否为字符串、数值、布尔值或 undefined。如果是对象或null，返回Object。但 null 不属于引用数据类型,typeof 除了判断 function 函数会识别,其他的引用类型输出为 object**instanceof**：一般是用来判断引用数据类型,但不能正确判断基本数据类型,根据在原型链中查找判断当前数据的原型对象是否存在返回布尔类型
        
2.  执行上下文与作用域  
    执行上下文包括：全局**上下文**、函数**上下文**。  
    
    1.  变量对象
        
        1.  执行上下文中定义的所有变量和函数都存在于这个对象上，在浏览器中，全局上下文是window 对象
            
        2.  通过 var 定义的全局变量和函数会成为 window 对象的属性和方法
            
        3.  使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果一样的
            
        4.  上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。
            
    2.  作用域链  
        
        1.  决定了各级上下文中的代码在访问变量和函数时的顺序。
            
        2.  内部上下文可以通过作用域链访问外部上下文中的一切。
            
    3.  **作用域链增强**
        
        1.  某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执  
            行后会被删除。即：
            
            *   try/catch 语句的 catch 块：创建新的变量对象，它会包含要抛出的错误对象的声明。
                
            *   with语句：向作用域链前端添加指定的对象
                
3.  垃圾回收  
    垃圾回收：执行环境负责在代码执行时管理内存。  
    基本思路：确定哪个变量不会再使用，然后释放它占用的内存。周期性的。两种标记策略：标记清理和引用计数。  
    
    1.  标记清理(常用)  
        在垃圾回收程序运行的时候，会标记内存中存储的所有变量，然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后在被标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不了它们。然后垃圾回收程序做一次内存清理，销毁带标记的值并回收它们的内存。
        
    2.  **引用计数**  
        对每个值记录引用的次数，引用一次+1，引用的变量被其他值覆盖-1，释放引用次数为0的值的内存。  
        使用引用计数可能会遇到循环引用的问题
        
    3.  **性能**  
        如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要
        
    4.  内存管理
        
        1.  通过const 和 let 声明提升性能，他们都以块为作用域，可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。
            
        2.   隐藏类和删除操作
            
        3.  将内存占用量保持在一个较小的值可以让页面性能更好。
            
        4.  优化内存占用的最佳手段：保证在执行代码时只保存必要的数据。
            
        5.  若数据不再必要，把它设置为 null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用。
            
        6.  解除引用的关键：确保相关的值已经不在上下文里
            
    5.  内存泄漏  
        导致内存泄露大部分是不合理的引用导致的  
        
        1.  意外声明全局变量
            
        2.  定时器不使用不去清除，只要定时器还在运行，内存就不会被回收
            
        3.  闭包。只要闭包中返回的函数存在，函数中的变量就不能被清理，因为闭包一直在引用着它。
            
        4.  静态分配与对象池
            
            1.  如何减少浏览器执行垃圾回收的次数？
                
            2.  实际上，开发者可以间接控制触发垃圾回收的条件。
                
            3.  理论上，如果能够合理使用分配的内存，避免多余的垃圾回收，就可以保住因释放内存而损失的性能
                
            4.  浏览器决定何时运行垃圾回收程序的一个标准就是**对象更替**的速度。  
                如：调用这个函数会创建新对象，修改它，再返回给调用者。如果这个对象生命周期很短，则很快会被回收。如果频繁地调用这个函数，就可能有频繁的垃圾回收。  
                在哪里创建矢量可以不让垃圾回收调度程序盯上呢？**对象池**在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。  
                
            5.  静态分配是优化的一种极端形式。大多数情况下不考虑。
                
4.  总结
    
    *   JavaScript 交量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6种原始数据类型：Undefined、 Null、 Boolean、Number、string 和 symbol。原始值和引用值有以下特点。
        
        *   原姶值大小固定，因此保存在栈内存上。
            
        *   从一个变量到另一个交量复制原始值会创建该值的第二个副本。
            
        *   引用值是对象，存储在堆内存上。
            
        *   包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。
            
        *   从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个交量都指向同一个对象。
            
        *   typeof 操作符可以确定值的原始类型，而 instanceof操作符用于确保值的引用类型。
            
        *   任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域)。这个上下文（作用城）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。
            
        *   执行上下文分全局上下文、函数上下文和块级上下文。
            
        *   代码执行流每进人一个新上下文，都会创建一个作用域链，用于搜索变量和函数。
            
        *   函数或块的局部上下文不仅可以访问自己作用城内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。
            
        *   全局上下文只能访问全局上下文中的变量和的数，不能直接访问局部上下文中的任何数据。
            
        *    变量的执行上下文用于确定什么时候释放内存。
            
        *   Javascript是使用垃圾回收的编程语言．开发者不需要操心内存分配和回收。JavaSeript 的垃圾回收程序可以,总结如下：
            
        *   离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
            
        *   主流的坟圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。
            
        *   引用计数是另一种垃圾回收策略，需要记录值被引用了 多少次。JavaScript 引擎不再使用这种算法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象（如DOM 元素)。
            
        *   引用计数在代码中存在循环引用时会出现问题。
            
        *   解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。
            

  

## 第5章 基本引用类型

对象被认为是某个特定引用类型的实例。新对象通过使用new操作符后跟一个构造函数来创建。构造函数就是用来创建对象的函数。

1.  **Date**  
    Date 类型将日期保存为自 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。  
    **创建日期对象：**
    
    1.  Date.parse()方法接受一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数（接收的参数不表示日期则返回NaN）。  
          
        
    2.  Date.UTC()返回日期的毫秒表示，但使用的是跟Date.parse()不同的信息来生成这个值。
        
    3.  Date.now()返回表示方法执行时日期和时间的毫秒数。
        
    4.  继承的方法
        
        1.  Date 类型重写了 toLocaleString()、toString()和 valueOf()方法
            
        2.  重写后这些方法的返回值不同
            
        3.  toLocaleString()：返回与浏览器运行的本地环境一致的日期和时间（有AM、PM）
            
        4.  toString()：返回带时区信息的日期和时间（24时制）
            
        5.  toLocaleString() - 2/1/2019 12:00:00 AM
            
        6.  toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)
            
        7.  valueOf()：返回的是日期的毫秒表示，操作符（如小于号和大于号）可以直接使用它返回的值
            
    5.  日期格式化方法  
        ![image2023-11-24_14-40-18.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/8180135318765114356/confluenceIMG/198315529/195922351.png)  
        
2.  RegExp正则表达式
    
    1.  语法：![image2023-11-24_14-54-28.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/8180135318765114356/confluenceIMG/198315529/195922363.png)举个栗子：元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义  
        举个栗子：正则表达式可以用RegExp构造函数创建，接受俩个参数（都是字符串）第二个参数可选使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：
        
    2.  RegExp 实例属性  
        ![image2023-11-24_15-17-35.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/8180135318765114356/confluenceIMG/198315529/195922397.png)
        
    3.   RegExp 实例方法  
        exec()（主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。包含两个额外的属性：index和input，index是字符串中匹配模式的起始位置，input是要查找的字符串。）如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项，如果没有设置全局标记，则无论对同一个字符串调用多少次exec()，也只会返回第一个匹配的信息。test()：接收一个字符串参数。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。  
        正则表达式的valueOf()方法返回正则表达式本身。
        
    4.  RegExp 构造函数属性  
        RegExp 构造函数的所有属性都没有任何 Web 标准出处，因此不要在生产环境中使用它们。  
        RegExp构造函数本身的属性：  
        
        1.  在其他语言中，被称为静态属性
            
        2.  适用于作用域中的所有正则表达式
            
        3.  可以用全名或简写（使用中括号语法）访问  
            ![image2023-11-24_16-6-35.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/8180135318765114356/confluenceIMG/198315529/195922433.png)
            
3.  **原始值包装类型**  
    1.每当用到某个原始值的**方法或属性**时，后台都会创建一个相应原始**包装类型的对象**，从而暴露出操作原始值的各种方法。2.引用类型与原始值包装类型的主要区别：对象的生命周期：通过 new 实例化的对象：离开作用域时被销毁；自动创建的原始值包装对象：只存在于访问它的那行代码执行期间。  举例：  第二行：创建一个String对象，它有属性color=red，在第二行结束后销毁  第三行：创建一个String对象，它没有color，所以会访问到undefined，第三行结束后销毁3.Object 构造函数：能够根据传入值的类型返回相应原始值包装类型的实例。
    
    1.   Boolean（强烈建议永远不要使用Boolean 对象）
        
        1.  Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串"true"或"false"。
            
        2.  原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回"boolean"，但对引用值返回"object"。同样，Boolean 对象是 Boolean 类型的实例，在使用instaceof 操作符时返回 true，但对原始值则返回 false。
            
        3.  Boolean对象使用的很少，因为容易产生误会：所有对象在布尔表达式中都会自动转换为 true。  
            
    2.   Number（不建议直接实例化 Number 对象。）
        
        1.  在处理原始数值和引用数值时，typeof 和 instacnceof操作符会返回不同的结果：  
            
        2.  Number重写的方法：  
            
            1.  valueOf()：返回原始数值
                
            2.  toLocaleString()
                
            3.  toString():可选地接收一个表示基数的参数，并返回相应基数形式(基数进制)的数值字符串
                
            4.  toFixed()：返回包含指定小数点位数的数值字符串（超出则四舍五入），多个浮点数值的数学计算不一定得到精确的结果，可以表示有 0~20 个小数位的数值
                
            5.  toExponential()：科学记数法（指数记数法），接收一个参数，表示结果中小数的位数：let num = 10; console.log(num.toExponential(1)); // "1.0e+1" 
                
            6.  toPrecision()：
                
                1.  根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。
                    
                2.  接收一个参数，表示结果中数字的总位数（不包含指数）
                    
                3.  本质：根据数值和精度来决定调用toFixed()还是toExponential()
                    
                4.  会四舍五入（根据参数）
                    
            7.  isInteger()：是否为整数，小数位的0可能会让人误以为数值是一个浮点值
                
            8.  isSafeInteger(): 安全整数：从 Number.MIN\_SAFE\_INTEGER（-253 +1）到Number.MAX\_SAFE\_INTEGER（253-1），判断是否在安全整数范围内
                
    3.  String
        
        1.   JavaScript 字符
            
            1.  JavaScript 字符串由 16 位码元（code unit）组成,字符串的 length 属性表示字符串包含多少 16 位码元
                
            2.  相关方法：chartCodeAt():查看指定码元的字符编码，这个方法返回指定索引位置的码元值，索引以整数指定。fromCharCode()：根据给定的 UTF-16 码元创建字符串中的字符，这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串。
                
        2.   normalize()方法（略）
            
        3.  字符串操作方法
            
            1.  concat()：用于将一个或多个字符串拼接成一个新字串。但更常用的方式是使用加号操作符（+）
                
            2.  从字符串中提取子字符串的方法：这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数,第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。  
                
                1.  slice():
                    
                2.  substr:()
                    
                3.  substring()
                    
                4.  区别：
                    
                    1.  对 slice()和 substring()：第二个参数：提取结束的位置
                        
                    2.  对 substr()：第二个参数：返回的子字符串长度
                        
                    3.  任何情况下，省略第二个参数都意味着提取到字符串末尾，不会修改调用它们的字符串，只会返回提取到的原始新字符串值
                        
                    4.  某个参数是负值时：  
                        
                        1.  slice()：当slice方法的参数为负数时，则其先加上字符串/数组的长度
                            
                            1.  若第一个参数（表start位置）或者第二个参数（表end位置）为负数，则其对应的索引是这个参数加上字符串的长度
                                
                            2.  当负数参数都加上字符串长度变为正数后，若第一个参数（start）大于等于第二个参数（end），则取不到任何字符或数组,返回空字符串 “” / 空数组 \[\]
                                
                        2.  substr()：
                            
                            1.  第一个负参数值：代表开始位置从字符串右边开始往左取，比如：-1表示从右到左方向的第一个（原字符串最后一个字符），-2表示从右到左方向第二个（原字符串最后倒数第二个字符），
                                
                            2.  第二个负值：会将其转为0，无论第一个字符串为正值还是负值都返回空字符串""
                                
                        3.  substring()：所有负参数值会置为0，然后两个参数中较小数（即0）为取字符的开始位置，较大数为取字符的结束位置
                            
        4.   字符串位置方法
            
            1.  indexOf，lastIndexOf：从字符串中搜索传入的字符串，返回位置（没找到返回-1）  
                区别：
                
                1.  indexOf()：从字符串开头开始查找子字符串
                    
                2.  lastIndexOf()：从字符串末尾开始查找子字符串
                    
                3.  第二个参数（可选）：开始搜索的位置
                    
        5.   字符串包含方法
            
            1.  判断字符串是否包含另一个字符串
                
            2.  startsWith() 字符串是否由某个字符串开头，可以传第二个参数，表示开始搜索的位置
                
            3.  endsWith() 字符串是否由某个字符串结尾，可以传第二个参数，表示应该当作字符串末尾的位置
                
            4.  includes() 字符串中是否包含指定字符串，可以传第二个参数，表示开始搜索的位置
                
        6.   trim()
            
            1.  创建一个字符串的副本，删除前后所有的空格符（可以用在防止用户复制粘贴到空格，导致查不到数据），不影响之前的字符串
                
            2.  类似的方法还有：trimLeft()和trimRight()代表从字符串开始或末尾清理空格符。
                
        7.  repeat()
            
            1.  参数必须是整数，代表将字符串复制多少次，返回所有副本后的结果，不影响之前的字符串。
                
        8.  padStart()和 padEnd()
            
            1.  第一个参数代表要形成字符串的长度，第二个参数代表不够长度需要添加的字符串
                
            2.  示例
                
        9.  字符串迭代与解构
            
            1.  let message = "abcde";   
                console.log(\[...message\]); // \["a", "b", "c", "d", "e"\]
                
        10.  字符串大小写转换
            
            1.  toLowerCase()和toUpperCase()
                
        11.  字符串模式匹配方法 
            
            1.  match() 
                
                1.  跟 RegExp 对象的 exec()方法相同
                    
                2.  参数：正则表达式的字符串或RegExp对象
                    
                3.  返回的数组与 exec()方法的一样，第一个元素：与整个模式匹配的字符串，其他元素：与捕获组匹配的字符串（如果有）
                    
            2.  search()
                
                1.  参数和match()相同
                    
                2.  返回模式第一个匹配位置的索引，没找到返回-1
                    
                3.  从字符串开头向后匹配
                    
            3.  replace(）
                
                1.  第一个参数：一个RegExp对象活字符串，第二个参数：一个字符串或函数
                    
                2.  要想替换所有的子字符串，需要在第一个参数为正则表达式并且带全局标记
                    
                3.  当第二个参数是字符串时，需要注意有几个特殊的字符序列  
                    ![image2024-1-5_15-17-43.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/8180135318765114356/confluenceIMG/198315529/200674388.png)  
                    举例：  
                    
                    *   每个：全局标记/g
                        
                    *   以"at"结尾的词：(.at)
                        
                    *   替换成"word"后跟一对小括号：“word ($1)”
                        
                    *   捕获组匹配的内容：(.at)
                        
                4.  当第二个参数是函数  
                    举例
                    
                    *   在只有一个匹配项时，函数的三个参数：模式匹配的字符串、字符串开始匹配的位置、整个字符串
                        
                    *   在有多个捕获组的情况下：每个匹配捕获组的字符串会作为参数
                        
                    *   返回一个字符串，表示应该把匹配项替换成什么
                        
            4.  split()
                
                1.  是根据分隔符将字符串拆分成数组
                    
                2.  分隔符参数：字符串，RegExp对象
                    
                3.  第二个参数（可选）：数组大小，确保返回的数组不会超过指定大小  
                    示例：
                    
        12.  localeCompare()
            
            *   比较两个字符串，按照字母表顺序比较，先比较第一个字符，相同会继续比较下一个，不同的话。如果参数字符串的顺序在字符串前面返回1反之返回-1，字符串与字符串参数相等：一般是0
                
            *   这个用的比较少，具体比较参考此文档[https://blog.csdn.net/weixin\_42335036/article/details/125366705](https://blog.csdn.net/weixin_42335036/article/details/125366705)  
                示例
                
        13.   HTML 方法
            
4.  单例内置对象
    
    1.  Global对象  
        是一种兜底对象，所针对的是不属于任何对象属性和方法，在全局作用域中定义的变量和函数都会变成Global对象的属性  
        
        1.  URL 编码方法
            
            1.  encodeURI()和 encodeURIComponent()**方法**：
                
                *   ecnodeURI()方法用于对整个 URI 进行编码
                    
                *   encodeURIComponent()方法用于编码 URI 中单独的组件
                    
                *   一般使用 encodeURI()编码整个URI
                    
                *   只使用 encodeURIComponent()编码会追加到已有 URI 后的字符串
                    
            2.  **decodeURI()和 decodeURIComponent()**
                
            
            *   *   decodeURI()只对使用 encodeURI()编码过的字符解码
                    
                *   decodeURIComponent()解码所有被 encodeURIComponent()编码的字符
                    
        2.  eval()方法  
            这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。下面这俩条语句等价  
            eval("console.log('hi')");   
            console.log("hi");
            
        3.  Global 对象属性  
            分为：特殊值和构造函数。
            
        4.  window 对象
            
            *   浏览器将 window 对象实现为 Global对象的代理
                
            *   所有全局作用域中声明的变量和函数都变成了 window 的属性
                
            *   详情见第12章
                
    2.   Math  
        注意：Math 对象上提供的计算要比直接在 JavaScript 实现快得多： Math 对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但， Math 计算的精度会因浏览器、操作系统、指令集和硬件而异。  
        
        1.  min()和 max()方法:
            
            *   接收任意多个参数
                
            *   返回最小/最大值
                
        2.  舍入方法
            
            *   Math.ceil()：向上舍入为最接近的整数
                
            *   Math.floor()：向下舍入为最接近的整数
                
            *   Math.round()：四舍五入
                
            *   Math.fround()：返回数值最接近的单精度（32 位）浮点值表示
                
        3.  random()方法
            
            *   返回一个\[0,1)内的随机数
                
            *   示例：想从 1~10 范围内随机选择一个数
                
            *   若是为了加密而需要生成随机数，使用window.crypto.getRandomValues()  
                
        4.  其他方法  
            ![image2024-1-5_16-56-15.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/confluenceImport/8180135318765114356/confluenceIMG/198315529/200674567.png)
            

