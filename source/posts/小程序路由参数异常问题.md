# 2025-10-15 逯跃明 小程序路由参数异常问题

# 问题

问题源自于阿克苏阳光的项目上，反馈了一个功能跳转后页面解析的问题，在路径参数中有”&“符号时控制台会报错。

复现问题

```vue
//路由跳转
const data = {
  a: "abc",
  b: "@233&&4222",
  c: "ccc"
};
navigateTo("/pages/serviceModule/changeHeat/changeHeat", data);
```

跳转后，控制台

![image.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/meonarbox06WrqXx/img/c3c57ed8-475a-47c2-ac0e-b3cc6e94571f.png)

相关的代码

```vue
onLoad: function (routerData) {
  const { cusId, customerList, yearInfo, reasonInfoId } = JSON.parse(
    routerData.params
  );
  this.cusId = cusId;
  this.customerList = customerList;
  this.yearInfo = yearInfo;
  this.reasonInfoId = reasonInfoId;
}
```

# 分析

问题比较明显，当 navigateTo 函数传递包含特殊字符（如 &&）的参数时，这些字符会破坏 URL 查询字符串的解析，导致 JSON 解析错误。

原理是传递包含特殊字符的数据时（如 "@233&&4222"），& 符号在 URL 中是参数分隔符。未编码时会导致 && 后的内容被当作新的参数，流程是

#### 1、处理相关数据

```vue
// 在 navigateTo 中
const url = props ? `${url}?params=${JSON.stringify(props)}` : url;
```

JSON.stringify(data) 的结果

```vue
{"a":"abc","b":"@233&&4222","c":"ccc"}
```

#### 2、生成url

```vue
/pages/serviceModule/changeHeat/changeHeat?params={"a":"abc","b":"@233&&4222","c":"ccc"}
```

#### 3、小程序解析

小程序框架会按照 URL 规范解析这个地址，遇到 & 会认为是参数分隔符：

```vue
// 小程序实际解析结果：
{
  params: '{"a":"abc","b":"@233',    //  被截断
  // 后面的 & 被当作新参数的开始
  '4222","c":"ccc"}': ''              
}
```

#### 4、数据接收

```vue
onLoad(routerData) {
  // routerData.params = '{"a":"abc","b":"@233'  （不完整的JSON）
  const data = JSON.parse(routerData.params); 
}
```

如图

![image.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/meonarbox06WrqXx/img/0c49b649-3eeb-4ed6-847a-27bfa17e0f33.png)

# 处理

### 方案一

处理方式可以是在 navigateTo 函数中用 encodeURIComponent() 对 JSON 字符串进行编码。

```vue
export const navigateTo = (url, props) => {
  return uniApi(uni.navigateTo, {
    url: props ? `${url}?params=${encodeURIComponent(JSON.stringify(props))}` : url
  });
};
```

然后在页面里进行decodeURIComponent，好处是简单直接，但是问题是这需要每一个页面都需要调用decodeURIComponent

### 方案二

创建一个全局 mixin，自动处理所有页面的 onLoad 参数：

```vue
// 在 main.js 中
Vue.mixin({
  onLoad(options) {
    // 如果有 params 参数，自动解码并挂载到 this.$routerParams
    if (options.params) {
      try {
        this.$routerParams = JSON.parse(decodeURIComponent(options.params));
      } catch (e) {
        this.$routerParams = {};
      }
    }
  }
})

// 各个页面使用
onLoad(routerData) {
  const { cusId, customerInfo } = this.$routerParams;
  // 或者向后兼容
  const params = this.$routerParams || JSON.parse(routerData.params);
}
```

这个方案需要新的开发规范

### 方案三

使用 uni-app 的 eventChannel 通信，uni-app 2.8.9+ 支持 eventChannel 页面间通信

```vue
// 发送页面
export const navigateTo = (url, data) => {
  return uni.navigateTo({
    url: url,
    success: function(res) {
      // 通过 eventChannel 向被打开页面传送数据
      res.eventChannel.emit('acceptDataFromOpenerPage', { data })
    }
  })
}

// 接收页面
onLoad() {
  const eventChannel = this.getOpenerEventChannel();
  eventChannel.on('acceptDataFromOpenerPage', (data) => {
    console.log(data);
    this.customerInfo = data.data;
  })
}
```

官方的通信方式，但是同样需要改动

# 方案四

在 main.js 或 utils/router.js 中代理原生方法

```vue
// 保存原始方法
const originalNavigateTo = uni.navigateTo;

// 重写方法
uni.navigateTo = function(options) {
  // 如果 url 中包含 params，自动编码
  if (options.url && options.url.includes('params=')) {
    const [path, query] = options.url.split('?');
    const params = new URLSearchParams(query);
    
    if (params.has('params')) {
      const paramsValue = params.get('params');
      // 如果还没编码过（简单判断），就编码
      if (!paramsValue.includes('%7B')) {
        params.set('params', encodeURIComponent(paramsValue));
        options.url = `${path}?${params.toString()}`;
      }
    }
  }
  
  return originalNavigateTo.call(this, options);
}
```

修改了源码，有一些风险，可能会影响其他的依赖或者冲突。

最后分析

| 对比维度 | 方案1: encodeURIComponent | 方案2: 全局Mixin | 方案3: eventChannel | 方案4: 代理原生API |
| --- | --- | --- | --- | --- |
| 改动代码量 | 29个文件 | 2个文件 | 29个文件 | 2个文件 |
| 新页面开发 | 手动 | 自动 | 需使用eventChannel | 自动 |
| 支持刷新/分享 | ✅ | ✅ | ❌ | ✅ |
| 数据大小限制 | 小 | 小 | 大 | 小 |
| 调试难度 | 简单 | 简单 | 困难 | 一般 |
| 版本要求 | 无 | 无 | uni-app 2.8.9+ | 无 |
| 技术风险 | 低 | 低 | 中 | 中高 |

1.  如果需要分享、刷新、外部链接，eventChannel 是不支持这些场景的；
    
2.  数据量大，使用eventChannel；
    
3.  改动无成本，对心智无负担，使用代理方案，就是调试相对复杂，拓展有一定风险；
    
4.  考虑最稳定的话直接改动每个页面；
    

# 结论

使用代理+Mixin

职责划分

| _层级_ | _职责_ |
| --- | --- |
| 代理层 | 发送端自动编码，不需要在router里或者页面中手动编码 |
| Mixin层 | 接收端自动解码，不需要在页面中手动解码 |

虽然mixin有全局污染，代理有冲突风险，但是我觉得收益大于成本，